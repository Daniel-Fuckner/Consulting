\section{Sequential Pattern Mining}\label{spm}

\subsection{Überblick}

Überarbeiten!!!\\
\textit{Sequential pattern mining} entdeckt häufige \textit{subsequences} (dt. Teilfolgen) in Datenbanken. Sogenannte \textit{sequence databases} bestehen aus Transaktionen, die jeweils \textit{items} enthalten, welche der Zeit nach geordnet sind. Die Daten lassen sich also mit dem Schema [Transaction/ID, <Ordered Sequence Items>] darstellen.\\
Ein Anwendungsfeld ist die Warenkorbanalyse. Angenommen es wird das Kaufverhalten in einem Supermarkt einen Monat lang beobachtet, dann könnte [Kunde 1, <(Brot, Milch), (Brot, Milch, Tee), (Zucker), (Milch, Salz)>]; [Kunde 2, <(Brot), (Milch, Tee)>] eine Beispiel-Datenbank sein. Kunde 1 war vier mal im beobachteten Monat im Supermarkt einkaufen, wobei Kunde 2 nur zweimal einkaufen war. Der Kunde kann nur eins oder auch mehrere \textit{items} pro Besuch einkaufen. Im Falle von mehreren \textit{items} spricht man von \textit{itemsets}.\\
\textit{Web usage mining} ist das am weitesten verbreitete Anwendungsfeld von \textit{sequential pattern mining} in der Literatur (\cite{lu_ezeife,wang_han,goethals}). Unter der Annahme, dass ein Internetnutzer nur eine Webseite an einem Zeitpunkt aufrufen kann, besteht die Folge von geordneten \textit{items} nur aus einzelnen \textit{items} und nicht aus \textit{itemsets}. Ist also eine Menge von \textit{items I = \{a, b, c, d, e\}} gegeben, die beispielsweise verschiedene Webseiten repräsentieren, so könnte eine Datenbank mit zwei Nutzern folgendermaßen aussehen: [Nutzer 1, <abedcab>]; [Nutzer 2, <edcaa>] (\cite[3:1-3:2]{taxonomy}).

\subsection{Problemstellung}
Das Problem wurde erstmals im Jahre 1995 in der Arbeit \textit{Mining Sequential Patterns} \cite{aprioriall} von Agrawal \& Srikant vorgestellt. Es ist eine Datenbank $D$ von Transaktionen gegeben, wobei jede Transaktion eine ID, den Zeitpunkt der Transaktion und die dazugehörigen items enthält. Für jede ID können mehrere Transaktionen existieren allerdings nie zwei oder mehr Transaktionen mit dem selben Zeitpunkt.\\
Ein itemset $i=(i_1i_2...i_m)$ ist eine nichtleere Menge von items $i_j$ und eine Sequenz $s=<s_1s_2...s_n>$ eine geordnete Liste von itemsets $s_j$. Ohne Beschränkung der Allgemeinheit wird angenommen, dass die Menge der items auf eine Menge von fortlaufenden ganzen Zahlen abgebildet wird.\\
Eine Sequenz $<a_1a_2...a_n>$ heißt Subsequenz einer anderen Sequenz $<b_1b_2...b_m>$ wenn ganze Zahlen $i_1<i_2<...<i_n$ existieren, so dass $a_1\subseteq b_{i_1}$, $a_2\subseteq b_{i_2}$, ..., $a_n\subseteq b_{i_n}$ gilt. Beispielsweise ist $<(1)(58)(27)>$ Subsequenz von $<(15)(248)(358)(27)>$, da $(1)\subseteq(15)$, $(58)\subseteq(358)$ und $(27)\subseteq(27)$ aber $<(27)>$ keine Subsequenz von $<(2)(7)>$ und umgekehrt. Eine Sequenz heißt maximal in einer Menge von Sequenzen, wenn sie von keiner Sequenz in dieser Menge Subsequenz ist.\\
Die Transaktionen einer ID können als Sequenz verstanden werden. Jede Transaktion entspricht dabei einem itemset und die nach den Zeitpunkten $T_1,T_2,...,T_n$ geordneten Transaktionen entsprechen einer Sequenz $<itemset(T_1)itemset(T_2)...itemset(T_n)>$. Der support einer Sequenz $s$ ist der Anteil der IDs, die $s$ unterstützen, das heißt deren Sequenz Subsequenz von $s$ sind. Eine Sequenz mit $k$ items wird auch k-Sequenz genannt.\\
Das Problem des sequential pattern mining besteht darin, in einer Datenbank $D$ unter allen existierenden Sequenzen die maximalen Sequenzen zu finden, deren support größer oder gleich einem festgelegten minimalen support $min\_sup$ $\xi$ ist.

\subsection{Auswahl geeigneter Algorithmen}

In den letzten zwei Jahrzehnten wurden im Forschungsfeld des sequential pattern mining eine Vielzahl von Algorithmen entwickelt (\cite{hvsm,lapin,aprioriall,gsp,psp,spam,freespan,prefixspan,wapmine,fsminer,discall,spade,plwap}; \textbf{die die an anderer stelle zitiert werden, hier später löschen}). Im Folgenden werden verschiedene Arten von Algorithmen sowie Merkmale anhand derer deren Qualität bewertet werden kann vorgestellt. Anschließend wird ausgearbeitet, welche dieser Algorithmen für die vorliegenden Daten am besten geeignet sind. Die Algorithmen lassen sich in die Kategorien \textit{apriori-based}, \textit{pattern-growth} und \textit{early-pruning} einteilen, wobei es auch hybride Algorithmen gibt.\\

\subsubsection{Apriori-Based}

Apriori-basierte Algorithmen waren Mitter der neunziger Jahre die ersten auf dem Feld des sequential pattern mining und hängen vor allem von der apriori Eigenschaft ab. Diese besagt, dass alle nichtleeren Teilmengen eines häufigen itemsets ebenfalls häufig sein müssen. Sie können als monoton fallend verstanden werden da für jede Sequenz, die den minimalen support $min\_sup$ $\xi$ nicht erfüllt auch all deren Übermengen diesen nicht erfüllen. Das bedeutet, es gilt Gleichung (\ref{supInEquation}).
\begin{align}
	X \subseteq Y \Rightarrow support(Y) \leq support(X) \text{  für  } X,Y \subseteq J, J: \text{  Menge aller items in  } D \label{supInEquation}
\end{align}

Dmit sind für eine nicht häufige Sequenz auch alle Übermengen nicht häufig und für eine häufige Sequenz alle Untermengen ebenfalls häufig. Apriori-Algorithmen sind durch drei Hauptmerkmale gekennzeichnet.
Ein Nachteil ist die \textit{generate-and-test}-Eigenschaft. Sie bringt mit sich, dass ausgiebige join-Operatoren verwendet werden, die die Sequenzen in jedem Schritt um nur ein item vergrößern und gegen den minimalen support testen. Dadurch ensteht eine enorme Anzahl von Kandidat-Sequenzen, die bereits zu Beginn des Algorithmus viel Speicher aufbrauchen. Sind beispielsweise $n$ häufige 1-Sequenzen und $min\_sup=1$ gegeben. Dann werden $n^2+\binom{n}{2}$  Kandidat-2-Sequenzen und $\binom{n}{m}$ Kandidat-m-Sequenzen erzeugt.

\subsection{SPADE}
Im Folgenden wird der SPADE Algorithmus \cite{spade} vorgestellt, der in dem R-Paket \textit{arulesSequences} \cite{arulesSequences} implementiert ist. Dieser sucht häufige Sequenzen von itemsets, das heißt er kann auch mit Daten umgehen, die mehrere items pro Zeitpunkt enthalten. Da ein Benutzer nur eine Webseite zum exakt selben Zeitpunkt besucht werden kann, ist diese Eigenschaft in diesem Fall nicht relevant. Die Daten werden vertikal bezüglich der IDs angeordnet. Die zweite Spalte enthält die Zeit des Kontaktes, die dritte Spalte die Anzahl der items zu diesem Zeitpunkt und die vierte Spalte die eigentlichen items. Bei den gegebenen Daten sind die Zeitpunkte die Positionen und damit pro ID von eins bis zur Anzahl der Positionen für die ID durchnummeriert. Die Anzahl der items in der dritten Spalte ist immer gleich eins und die vierte Spalte enthält pro Zeile nur ein item (Tabelle \ref{input}).\\
\begin{table}[hbt]\label{input}
\centering
\begin{tabular}{c|c|c|c}
ID & Zeitpunkt & Anzahl Items & Items \\ \hline
1  & 1				 & 1						& A \\
1  & 2				 & 1						& C \\
1  & 3				 & 1						& A \\
1  & 4				 & 1						& B \\
2  & 1				 & 1						& C \\
3  & 1				 & 1						& D \\
3  & 2				 & 1						& A 
\end{tabular}
\caption{Beispiel für eine Input-Datenbank für den SPADE-Algorithmus}
\end{table}


%ÜBERFLÜSSIG:
%\subsubsection{Verbandstheorie}
%Eine gute Einführung zur Verbandstheorie findet man in \cite{lattices}. Eine Menge $P$ heißt geordnete Menge, wenn für alle $X,Y,Z \in P$ die binäre Relation $\leq$ reflexiv (\ref{refl}), asymmetrisch (\ref{asym}) und transitiv (\ref{trans}) ist. Für $S \subseteq P$ heißt $X \in P$ obere (untere) Schranke von $S$, wenn $s \leq X$ ($s \geq X$) für alle $s \in S$.
%\begin{align}
%	X\leq X \label{refl} \\
%	X \leq Y, Y \leq X \Rightarrow X = Y \label{asym} \\
%	X \leq Y, Y \leq Z \Rightarrow X \leq Z \label{trans}
%\end{align}
%\cite{spade}

\subsubsection{Berechnung des Supports}
In diesem Abschnitt wird beschrieben, wie der Support einer Sequenz berechnet wird.
\begin{table}[hbt]\label{idlist}
\centering
\begin{tabular}{c|c|c|c|c|c|c|c}
\multicolumn{2}{c|}{A} & \multicolumn{2}{c|}{B} & \multicolumn{2}{c|}{C} & \multicolumn{2}{c}{D} \\ \hline
ID & Zeitpunkt & ID & Zeitpunkt & ID & Zeitpunkt & ID & Zeitpunkt \\
1	 & 1				 & 1  & 4				  & 1  & 2				 & 3  & 1 \\
1  & 3				 &    &				    & 2  & 1				 &    & \\
3  & 2				 &    &				    &    &  				 &    & \\
\end{tabular}
\caption{ID-Listen für die items}
\end{table}